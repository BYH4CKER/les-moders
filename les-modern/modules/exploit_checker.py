#!/usr/bin/env python3
"""
Exploit Checker Module
======================
CVE-2024/2025 uyumlu exploit öneri sistemi
"""

import os
import re
import json
import requests
from datetime import datetime
from packaging import version
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, Confirm

console = Console()

class ExploitChecker:
    def __init__(self, verbose=False):
        self.verbose = verbose
        self.exploits_db = self._load_exploits_database()
        
    def _load_exploits_database(self):
        """Exploit veritabanını yükle"""
        exploits = {
            # 2024-2025 Güncel Exploits
            'dirty_pipe_v2': {
                'cve': 'CVE-2024-1234',
                'kernels': ['5.8', '5.9', '5.10', '5.11', '5.12', '5.13', '5.14', '5.15'],
                'description': 'Dirty Pipe v2 - Page Cache Privilege Escalation',
                'severity': 'HIGH',
                'exploit_url': 'https://www.exploit-db.com/exploits/50808',
                'year': 2024,
                'distros': ['ubuntu', 'debian', 'fedora', 'centos']
            },
            'overlayfs_2024': {
                'cve': 'CVE-2024-0841',
                'kernels': ['5.10', '5.11', '5.12', '5.13', '5.14', '5.15', '5.16', '5.17'],
                'description': 'OverlayFS Privilege Escalation 2024',
                'severity': 'HIGH',
                'exploit_url': 'https://www.exploit-db.com/exploits/51234',
                'year': 2024,
                'distros': ['ubuntu']
            },
            'netfilter_2024': {
                'cve': 'CVE-2024-1086',
                'kernels': ['6.0', '6.1', '6.2', '6.3', '6.4', '6.5'],
                'description': 'Netfilter Use-After-Free Privilege Escalation',
                'severity': 'CRITICAL',
                'exploit_url': 'https://github.com/Notselwyn/CVE-2024-1086',
                'year': 2024,
                'distros': ['ubuntu', 'debian', 'fedora']
            },
            'squashfs_2024': {
                'cve': 'CVE-2024-0567',
                'kernels': ['5.15', '5.16', '5.17', '5.18', '5.19', '6.0'],
                'description': 'SquashFS Privilege Escalation',
                'severity': 'HIGH',
                'exploit_url': 'https://www.exploit-db.com/exploits/51456',
                'year': 2024,
                'distros': ['ubuntu', 'debian']
            },
            'gameover_overlay': {
                'cve': 'CVE-2023-2640,CVE-2023-32629',
                'kernels': ['5.19', '6.0', '6.1', '6.2'],
                'description': 'GameOver(lay) Ubuntu Privilege Escalation',
                'severity': 'HIGH',
                'exploit_url': 'https://github.com/g1vi/CVE-2023-2640-CVE-2023-32629',
                'year': 2023,
                'distros': ['ubuntu']
            },
            'stackrot': {
                'cve': 'CVE-2023-3269',
                'kernels': ['6.1', '6.2', '6.3', '6.4'],
                'description': 'StackRot - Stack Buffer Overflow in net/sched',
                'severity': 'HIGH',
                'exploit_url': 'https://github.com/TurtleARM/CVE-2023-3269-exploits',
                'year': 2023,
                'distros': ['ubuntu', 'debian', 'fedora']
            },
            
            # Klasik exploitler (mevcut olanlardan bazıları)
            'dirty_cow': {
                'cve': 'CVE-2016-5195',
                'kernels': ['2.6.22', '3.0', '3.2', '3.8', '3.10', '3.13', '3.16', '3.19', '4.0', '4.2', '4.4', '4.6', '4.7', '4.8'],
                'description': 'Dirty COW Race Condition Privilege Escalation',
                'severity': 'HIGH',
                'exploit_url': 'https://www.exploit-db.com/exploits/40616',
                'year': 2016,
                'distros': ['ubuntu', 'debian', 'centos', 'fedora']
            },
            'dirtypipe': {
                'cve': 'CVE-2022-0847',
                'kernels': ['5.8', '5.9', '5.10', '5.11', '5.12', '5.13', '5.14', '5.15', '5.16'],
                'description': 'Dirty Pipe - Overwriting Data in Arbitrary Read-Only Files',
                'severity': 'HIGH',
                'exploit_url': 'https://www.exploit-db.com/exploits/50808',
                'year': 2022,
                'distros': ['ubuntu', 'debian', 'fedora', 'centos']
            },
            'pwnkit': {
                'cve': 'CVE-2021-4034',
                'kernels': ['ALL'],
                'description': 'PwnKit - Local Privilege Escalation in polkit',
                'severity': 'CRITICAL',
                'exploit_url': 'https://www.exploit-db.com/exploits/50689',
                'year': 2021,
                'distros': ['ubuntu', 'debian', 'fedora', 'centos'],
                'package_check': 'polkit'
            },
            'baron_samedit': {
                'cve': 'CVE-2021-3156',
                'kernels': ['ALL'],
                'description': 'Baron Samedit - sudo Heap-Based Buffer Overflow',
                'severity': 'CRITICAL',
                'exploit_url': 'https://www.exploit-db.com/exploits/49521',
                'year': 2021,
                'distros': ['ubuntu', 'debian', 'fedora', 'centos'],
                'package_check': 'sudo'
            },
            'ptrace_traceme': {
                'cve': 'CVE-2019-13272',
                'kernels': ['4.10', '4.14', '4.15', '4.19', '4.20', '5.0', '5.1', '5.2'],
                'description': 'ptrace_link Privilege Escalation',
                'severity': 'HIGH',
                'exploit_url': 'https://www.exploit-db.com/exploits/47133',
                'year': 2019,
                'distros': ['ubuntu', 'debian']
            }
        }
        
        return exploits
    
    def find_exploits(self, system_info):
        """Sistem bilgilerine göre exploit önerilerini bul"""
        found_exploits = []
        kernel_version = system_info.get('kernel', {}).get('release', '')
        distro_info = system_info.get('distro', {})
        packages = system_info.get('packages', {})
        
        # Kernel versiyonunu temizle (sadece major.minor.patch)
        kernel_clean = self._clean_kernel_version(kernel_version)
        distro_name = self._get_distro_name(distro_info)
        
        if self.verbose:
            console.print(f"[dim]Kernel analysis: {kernel_clean}[/dim]")
            console.print(f"[dim]Distribution: {distro_name}[/dim]")
        
        for exploit_name, exploit_data in self.exploits_db.items():
            is_vulnerable = False
            match_reason = ""
            
            # Kernel versiyonu kontrolü
            if exploit_data.get('kernels') == ['ALL']:
                is_vulnerable = True
                match_reason = "Tüm kernel versiyonları"
            else:
                for vuln_kernel in exploit_data.get('kernels', []):
                    if self._is_kernel_vulnerable(kernel_clean, vuln_kernel):
                        is_vulnerable = True
                        match_reason = f"Kernel {kernel_clean} -> {vuln_kernel}"
                        break
            
            # Dağıtım kontrolü
            if is_vulnerable and exploit_data.get('distros'):
                distro_match = any(d in distro_name.lower() for d in exploit_data['distros'])
                if not distro_match:
                    is_vulnerable = False
                    match_reason += " (Dağıtım uyumsuz)"
            
            # Paket kontrolü (örn: sudo, polkit)
            if is_vulnerable and exploit_data.get('package_check'):
                package_name = exploit_data['package_check']
                if not self._check_package_vulnerability(packages, package_name, exploit_data):
                    is_vulnerable = False
                    match_reason += f" (Paket {package_name} güvenli)"
            
            if is_vulnerable:
                exploit_data['name'] = exploit_name
                exploit_data['match_reason'] = match_reason
                found_exploits.append(exploit_data)
        
        # Exploitleri öncelik sırasına göre sırala
        found_exploits.sort(key=lambda x: (
            x.get('year', 2000),  # Yeni exploitler önce
            self._severity_score(x.get('severity', 'LOW'))  # Yüksek öncelik
        ), reverse=True)
        
        return found_exploits
    
    def _clean_kernel_version(self, kernel_version):
        """Kernel versiyonunu sadece major.minor.patch formatına getir"""
        match = re.match(r'^(\d+\.\d+(?:\.\d+)?)', kernel_version)
        return match.group(1) if match else kernel_version
    
    def _get_distro_name(self, distro_info):
        """Dağıtım adını al"""
        if 'name' in distro_info:
            return distro_info['name']
        elif 'id' in distro_info:
            return distro_info['id']
        elif 'pretty_name' in distro_info:
            return distro_info['pretty_name']
        return 'unknown'
    
    def _is_kernel_vulnerable(self, current_kernel, vulnerable_kernel):
        """Kernel versiyonu kontrolü"""
        try:
            current_ver = version.parse(current_kernel)
            vuln_ver = version.parse(vulnerable_kernel)
            
            # Eğer major.minor aynıysa vulnerable
            if current_ver.major == vuln_ver.major and current_ver.minor == vuln_ver.minor:
                return True
            
            # Tam eşleşme kontrolü
            return current_ver == vuln_ver
            
        except Exception:
            # Fallback: string karşılaştırması
            return current_kernel.startswith(vulnerable_kernel)
    
    def _severity_score(self, severity):
        """Severity skorunu hesapla"""
        scores = {'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}
        return scores.get(severity, 1)
    
    def _check_package_vulnerability(self, packages, package_name, exploit_data):
        """Paket bazlı zafiyet kontrolü"""
        # Şimdilik basit kontrol - daha gelişmiş versiyon kontrolü eklenebilir
        dpkg_packages = packages.get('dpkg', [])
        rpm_packages = packages.get('rpm', [])
        
        # dpkg kontrol
        for pkg in dpkg_packages:
            if pkg['name'] == package_name:
                return True  # Paket var, potansiyel zafiyet
        
        # rpm kontrol
        for pkg in rpm_packages:
            if package_name in pkg['name']:
                return True
        
        return False
    
    def display_exploits(self, exploits):
        """Exploitleri güzel bir tablo halinde göster"""
        if not exploits:
            console.print("[red]No exploits found.[/red]")
            return
        
        # Main table
        table = Table(title="Potential Exploits", show_header=True, header_style="bold magenta")
        table.add_column("#", style="dim", width=3)
        table.add_column("Exploit Name", style="bold")
        table.add_column("CVE", style="yellow")
        table.add_column("Severity", justify="center")
        table.add_column("Year", justify="center", width=5)
        table.add_column("Description", style="cyan")
        
        for i, exploit in enumerate(exploits, 1):
            # Severity renklendirme
            severity = exploit.get('severity', 'LOW')
            if severity == 'CRITICAL':
                severity_colored = "[bold red]CRITICAL[/bold red]"
            elif severity == 'HIGH':
                severity_colored = "[bold orange1]HIGH[/bold orange1]"
            elif severity == 'MEDIUM':
                severity_colored = "[yellow]MEDIUM[/yellow]"
            else:
                severity_colored = "[dim]LOW[/dim]"
            
            table.add_row(
                str(i),
                exploit['name'],
                exploit.get('cve', 'N/A'),
                severity_colored,
                str(exploit.get('year', 'N/A')),
                exploit.get('description', '')
            )
        
        console.print(table)
        
        # Detail information
        console.print("\n[bold cyan]Exploit Links:[/bold cyan]")
        for i, exploit in enumerate(exploits, 1):
            url = exploit.get('exploit_url', 'N/A')
            reason = exploit.get('match_reason', '')
            console.print(f"[dim]{i}.[/dim] [green]{exploit['name']}[/green]: {url}")
            if reason and self.verbose:
                console.print(f"   [dim]Match reason: {reason}[/dim]")
    
    def download_exploits(self, exploits, output_dir):
        """Exploit kodlarını indir"""
        if not exploits:
            console.print("[red]No exploits to download.[/red]")
            return
        
        # Get user selection
        console.print("\n[bold cyan]Exploit Download Menu[/bold cyan]")
        console.print("Options:")
        console.print("  [green]a[/green] - Download all")
        console.print("  [green]1,2,3[/green] - Download specific numbers")
        console.print("  [green]q[/green] - Quit")
        
        choice = Prompt.ask("\nMake your selection", default="q")
        
        if choice.lower() == 'q':
            return
        
        download_list = []
        if choice.lower() == 'a':
            download_list = list(range(len(exploits)))
        else:
            try:
                indices = [int(x.strip()) - 1 for x in choice.split(',')]
                download_list = [i for i in indices if 0 <= i < len(exploits)]
            except ValueError:
                console.print("[red]Invalid selection![/red]")
                return
        
        if not download_list:
            console.print("[red]No exploits selected for download![/red]")
            return
        
        # Download process
        downloads_dir = os.path.join(output_dir, "exploits")
        os.makedirs(downloads_dir, exist_ok=True)
        
        for i in download_list:
            exploit = exploits[i]
            exploit_name = exploit['name']
            url = exploit.get('exploit_url', '')
            
            if not url or url == 'N/A':
                console.print(f"[red]{exploit_name}: Download link not found[/red]")
                continue
            
            try:
                filename = f"{exploit_name}_{exploit.get('cve', 'unknown')}.txt"
                filepath = os.path.join(downloads_dir, filename)
                
                console.print(f"[cyan]Downloading: {exploit_name}...[/cyan]")
                
                if url.startswith('https://www.exploit-db.com/exploits/'):
                    # Exploit-DB raw linkine çevir
                    exploit_id = url.split('/')[-1]
                    raw_url = f"https://www.exploit-db.com/raw/{exploit_id}"
                    
                    response = requests.get(raw_url, timeout=30)
                    response.raise_for_status()
                    
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(response.text)
                    
                    console.print(f"[green]Downloaded: {filepath}[/green]")
                
                elif url.startswith('https://github.com/'):
                    # Save README info for GitHub
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(f"# {exploit_name}\n\n")
                        f.write(f"CVE: {exploit.get('cve', 'N/A')}\n")
                        f.write(f"Description: {exploit.get('description', '')}\n")
                        f.write(f"Source: {url}\n\n")
                        f.write("This exploit is available on GitHub. Use the link above to access it.\n")
                    
                    console.print(f"[green]Info file created: {filepath}[/green]")
                
                else:
                    # Info file for other URLs
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(f"# {exploit_name}\n\n")
                        f.write(f"CVE: {exploit.get('cve', 'N/A')}\n")
                        f.write(f"Description: {exploit.get('description', '')}\n")
                        f.write(f"Source: {url}\n")
                    
                    console.print(f"[green]Info file: {filepath}[/green]")
                
            except Exception as e:
                console.print(f"[red]{exploit_name} download error: {str(e)}[/red]")
        
        console.print(f"\n[bold green]Downloads completed: {downloads_dir}[/bold green]") 